# 单片机的中断

[TOC]

## 中断基本概念

- 5个中断源，3个片内，2个片外。有固定入口地址，当CPU响应中断时，硬件自动形成这些地址，由此进入中断服务程序；5个中断源有两级中断优先级，可形成中断嵌套
- 多个中断源同时申请中断，会有中断优先级
- 中断嵌套：高优先级的中断请求能中断正在进行的较低级中断源处理

![1589082651894](\picture\中断1.png)

## 中断系统结构

#### 中断控制寄存器IE

IE寄存器的各位对应相应的中断源，如果允许该中断源中断则该位置1，禁止中断则该位0 。

![1589082807328](\picture\中断控制.png)

#### 外部中断方式选择寄存器TCON

![1589083084040](\picture\中断2.png)

#### 优先级设置寄存器IP

![1589083269579](\picture\优先级判别.png)

当几个中断源都设置为1时，根据查询顺序确定优先级，顺序为：

INT0 —> T0 —> INT1 —> T1 —>串行口 —>T2



## 中断响应过程

- 中断处理分四个阶段：中断请求、中断响应、中断处理、中断返回。
-  中断请求、中断响应过程由硬件完成。简单来说就是不用管
- 中断服务程序应根据需要进行编写。程序中要注意保护现场和恢复现场。就是中断之后你需要他干嘛
- 中断返回是通过执行一条RETI中断返回指令，使堆栈中被压入的断点地址送PC，从而返回主程序的断点继续执行主程序。另外RETI还有恢复优先级状态触发器的作用，因此不能以RET指令代替“RETI”指令。

#### 中断请求的撤除

- 对定时计数器T0、T1的溢出中断，CPU响应中断后，硬件自动清除中断请求标志TF0 TF1。
- 对边沿触发的外部中断INT1和INT0，CPU响应中断后硬件自动清除中断请求标志IE0和IE1。
- 对于串行口中断，CPU响应中断后，没有用硬件清除中断请求标志TI、RI，即这些中断标志不会自动清除，必须用软件清除，这是在编串行通信中断服务中应该注意的。
- 对电平触发的外部中断，CPU在响应中断时也不会自动清除中断标志，因此，在CPU响应中断后应立即撤除INT1或INT0的低电平信号。

## 中断应用编程

编程一般采用汇编或者C语言。(但我觉得我不会用汇编)。

编程主要就是对4个与中断有关的寄存器IE、TCON、IP、SCON进行控制或管理。有下面几个方面。

- 开中断总控开关EA，置位中断源的中断允许位。
- 对外部中断INT0、INT1应选择中断触发方式
- 多个中断源中断，应设定中断优先级，预置IP。
- 编写中断服务程序，并注意用保护现场和恢复现场，以免中断返回时，丢失原寄存器、累加器中的信息。



#### 中断服务程序的完整定义

**返回值函数名(［参数］)［模式］［再入］interrupt n［using m］**
       其中必选项interrupt n表示将函数声明为中断服务函数，n为中断源编号，可以是0～31间的整数，不允许是带运算符的表达式，n通常取以下：
0 外部中断0；
1 定时器/计数器0溢出中断
2 外部中断1；
3 定时器/计数器1溢出中断
4 串行口发送与接收中断
using m 定义函数使用的工作寄存器组，m的取值范围为0～3，可缺省。
函数由“RETI”指令终止

##### 举个例子

![1589084029283](\picture\中断例1.png)

```汇编语言
ORG 0000H
AJMP MAIN

ORG 0003H ；INT0中断入口
AJMP WBI ； 转中断服务程序

ORG 0030H ；主程序
MAIN: MOV P1，#0FH ；全灯灭，低四位输入
	SETB IT0 ； 边沿触发中断
	SETB EX0 ；允许外中断0中断
	SETB EA ；开中断开关
	SJMP $

WBI：MOV P1，#0FH ；P1先写入“1”且灯灭
	 MOV A，P1 ；输入开关状态
	SWAP A
	MOV P1，A ；输出到P1高4位
	RETI
END
```

下面时C语言实现：

```C语言
#include<reg51.h>

int0() interrupt 0 /*INT0中断函数*/
｛
	P1=0x0f; /*输入端先置1，灯灭*/
	P1<<=4;
	｝ /* 读入开关状态，并左移四位，开关反映在发光二极管上*/
	
main()
｛
	EA=1; /*开中断总开关*/
	EX0=1; /*允许INT0中断*/
	IT0=1; /*下降沿产生中断*/
	while(1); /*等待中断*/
｝
```

![1589091765419](\picture\Snipaste_2020-06-06_22-53-27.png)

```C
法1：在主程序中判断中断次数,程序如下：
#include<reg51.h>
char i;
code char tab［16］=｛0x3f,0x06,0x5b,0x4F,0x66，
0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79
,0x71｝;
int() interrupt 2
｛  
	i++； /*计中断次数*/
	P1=tab［i］;
  ｝ /*查表，次数送显示*/
  
main()
｛
    EA=1;
    EX1=1;
    IT1=1;
	ap5: P1=0x3f /*显示“0”*/
	for(i=0;i＜16;); /*当i小于16等待中断*/
	goto ap5;
 ｝ /*当i=16重复下一轮16次中断*/
```

```
法2：在中断程序中判断中断次数：
#include<reg51.h>
char i;
code char tab［16］=｛0x3f,0x06,0x5b,0x4F,0x66，0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71｝;
int() interrupt 2
｛ 
	i++;
	if(i＜16)P1=tab［i］；
	else｛i=0;P1=0x3f;｝
｝

main()
｛
    EA=1;
    EX1=1;
    IT1=1;
    P1=0x3f；
    while(1); /*等待中断*/
｝
```





## 小结

- 系列单片机有三个内部中断，二个外部中断。所谓外部中断就是在外部引脚上有产生中断所需要的信号。
- 每个中断源有固定的中断服务程序的入口地址(称矢量地址或向量地址)。当CPU响应中断以后单片机内部硬件保证它能自动的跳转到该地址。因此，此地址是应该熟记的，在汇编程序中，中断服务程序应存放在正确的向量地址内。
- 单片机的中断是靠内部的寄存器管理的，这就是中断允许寄存器IE，中断优先权寄存器IP ，CPU必须在开全局中断开关EA，开各中断源的中断开关，CPU才能响应该中断源的中断请求，其中缺一不可。
- 从程序表面看来，主程序和中断服务程序好象是没有关连的，只有掌握中断响应的过程，才能理解中断的发生和返回，看得懂中断程序，并能编写高质量中断程序。